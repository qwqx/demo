HashMap:
1.谈谈你理解的 HashMap，讲讲其中的 get put 过程。
2.1.8 做了什么优化？
3.是线程安全的嘛？
4.不安全会导致哪些问题？
5.如何解决？有没有线程安全的并发容器？
6.ConcurrentHashMap 是如何实现的？ 1.7、1.8 实现有何不同？为什么这么做？

7.HashMap\ConcurrentHashMap resize过程
8.ConcurrentHashMap迭代器是强一致性还是弱一致性？HashMap呢？
在遍历过程中，如果已经遍历的数组上的内容变化了，迭代器不会抛出ConcurrentModificationException异常。如果未遍历的数组上的内容发生了变化，则有可能反映到迭代过程中。这就是ConcurrentHashMap迭代器弱一致的表现。
ConcurrentHashMap的弱一致性主要是为了提升效率，是一致性与效率之间的一种权衡。要成为强一致性，就得到处使用锁，甚至是全局锁，这就与Hashtable和同步的HashMap一样了





ThreadLocal
1.当前线程持有ThreadLocalMap Entry<ThreadLocal,Obj>
2.set,get过程
3.resize 过程
4.Entry key WeakRefence & clean slot



2.synchronized

https://blog.csdn.net/zqz_zqz/article/details/70233767

锁升级的优化是针对于不同同步场景进行的优化，在不存在锁竞争的时候进入同步方法/代码块则使用偏向锁，存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，如果同步方法/代码块执行时间很短的话，采用轻量级锁虽然会占用cpu资源但是相对比使用重量级锁还是更高效的，但是如果同步方法/代码块执行时间很长，那么使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁。

**无锁：**MarkWord标志位01，没有线程执行同步方法/代码块时的状态。**偏向锁：**MarkWord标志位01（和无锁标志位一样）。偏向锁是通过在bitfields中通过CAS设置当前正在执行的ThreadID来实现的。假设线程A获取偏向锁执行代码块（即对象头设置了ThreadA_ID），线程A同步块未执行结束时，线程B通过CAS尝试设置ThreadB_ID会失败，因为存在锁竞争情况，这时候就需要升级为轻量级锁。**注：偏向锁是针对于不存在资源抢占情况时候使用的锁，如果被synchronized修饰的方法/代码块竞争线程多可以通过禁用偏向锁来减少一步锁升级过程。可以通过JVM参数-XX:-UseBiasedLocking = false来关闭偏向锁。****轻量级锁：**MarkWord标志位00。**轻量级锁是采用自旋锁的方式来实现的，自旋锁分为固定次数自旋锁和自适应自旋锁。轻量级锁是针对竞争锁对象线程不多且线程持有锁时间不长的场景,** 因为阻塞线程需要CPU从用户态转到内核态，代价很大，如果一个刚刚阻塞不久就被释放代价有大。**具体实现和升级为重量级锁过程：**线程A获取轻量级锁时会把对象头中的MarkWord复制一份到线程A的栈帧中创建用于存储锁记录的空间DisplacedMarkWord，然后使用CAS将对象头中的内容替换成线程A存储DisplacedMarkWord的地址。如果这时候出现线程B来获取锁，线程B也跟线程A同样复制对象头的MarkWord到自己的DisplacedMarkWord中，如果线程A锁还没释放，这时候那么线程B的CAS操作会失败，会继续自旋，当然不可能让线程B一直自旋下去，自旋到一定次数（固定次数/自适应）就会升级为重量级锁。**重量级锁：**通过对象内部监视器（monitor）实现，monitor本质前面也提到了是基于操作系统互斥（mutex）实现的，操作系统实现线程之间切换需要从用户态到内核态切换，成本非常高。**注：锁只可以升级不可以降级，但是偏向锁可以被重置为无锁状态。**

