#  一、运行时数据区

https://juejin.cn/post/6922363473183637511

## 1.本地方法栈

## 2.程序计数器

​          线程隔离性，每个线程工作时都有属于自己的程序计数器。
​          执行java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址

## 3.方法区

​      方法区用于存储编译后的class二进制文件，包含了JVM加载的类信息、常量、静态变量、即时编译后的代码等数据

###   1>存储内容

​			  a>即时编译后的代码:JIT，也就是即时编译优化,把部分热点字节码也直接编译成可执行的机器码，速度就和编译型的一样了
​              b>类信息：
​                  类型信息
​                  类型的常量池(constant pool): 实际的常量，域(成员变量)和方法的符号引用
​                  域(Field): 域名称、 域类型、域修饰符(public, private, protected, static, final, volatile, transient的某个子集)
​                  方法(Method):方法名称
​                             方法的返回类型(或void)
​                             方法参数的数量和类型(按顺序)
​                             方法的修饰符(public, private, protected,static,final,synchronized,native, abstract的一个子集)
​                             方法的字节码(bytecodes)
​                             操作数栈
​                             局部变量表及大小( abstract和native,方法除外)
​                             异常表( abstract和native方法除外)每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引
​                  类变量(除常量外的所有静态变量)

### 2>方法区特点

​              a.方法区的访问是线程安全的，由于所有的线程都共享方法区，所以方法区里的数据访问必须被设计成线程安全的
​              b.方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的
​              c.方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展
​              d.如果系统定义了太多的类，加载大量的第三方的jar包，Tomcat部署的工程过多，大量动态的生成反射类都有可能发生OOM，导致方法区溢出，会抛出内存溢出错误

### 3>演变

​              a.永久代
​                  永久代是一块连续的内存空间，它的垃圾回收是跟老年代的垃圾回收绑定的，两者只要有一个内存满了，两个区域都会进行垃圾回收
​              b.元空间
​                  元空间并不在虚拟机之中，而是使用的本地内存，这就导致了元空间的默认大小是没有限制的但是会受到本地内存大小的限制
​              c.原因
​              类的方法的信息大小难以确定，因此给永久带的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
​              永久带会为GC带来不必要的复杂性，并且回收效率偏低，在永久代中元数据可能会随着每一次Full GC发生而进行移动，而hotspot虚拟机每种类型的垃圾回收器都要特殊处理永久代中的元数据，分离出来以后可以简化Full GC。
​              永久代是hotspot VM的实现特有的，而别的JVM没有永久代这一说，Oracle可能会将hotspot和这个Jrockit合二为一 (不同的JVM实现)，所以元空间来替代可以比较好，方便统一
​              字符串常量池如果存在于永久代中，容易出现性能问题和内存溢出，频繁的发生Full GC

##  4.栈

### 1>栈帧

用于支持JVM进行方法调用和方法执行的数据结构
              a.方法的局部变量表
                  存放方法参数和方法内部定义的局部变量
              b.操作数栈
                  存放方法运行过程中产生的一些临时数据，目的是为了计算
              c.动态链接
                  符号引用
                  直接应用
                  符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。 另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接
              d:方法出口
                  方法正常退出时，方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。

## 5.堆

- 存放对象的实际内存区域
- 结构
- 分代收集理论



# 二、VM类加载的过程



## 1.JVM的启动过程

## 2.类加载的具体流程

### 1>加载

加载指的就是把class字节码文件**从各个来源**通过类加载器装载进内存，把字节码文件变成字节流，在加载阶段，Java虚拟机需要完成以下三件事情:

1. 通过一个**类的全限定名**来获取定义此类的二进制字节流。
2. 将这个字节流所代表的**静态存储结构**转化为**方法区的运行时数据结构**。
3. 在堆中生成一个代表这个类的**java.lang.Class对象**，作为方法区这个类的访问入口。

### 2>验证

- 文件格式验证 :验证字节流是否符合Class文件格式的规范
- 元数据验证:对**类的元数据信息进行校验**，保证不存在与《Java语言规范》定义相悖的元数据信息
- 字节 码验证:对**类的方法体(Class文件中的Code属性)** 进行校验分析，保证被校验类的方法在运行时不会做出危害 虚拟机安全的行为
- 符号引用验证:**对类自身以外(常量池中的各种符号引用)的各类信息进行匹配性校验**，通俗来说就是，该类是否缺少或者被禁止**访问它依赖的某些外部 类、方法、字段等资源

### 3>准备

把类中的静态变量 **(类变量)** 做一个初始值

### 4>解析

将常量池中的**符号引用替换成直接引用**的过程

- 静态解析

  符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为**直接引用**，这种转化被称为静态解析

  针对的是**静态方法（例如：main方法）或者其他不变的方法**，因为静态方法等到加载、分配完内存后，内存地址就不会变了，所以，可以在类加载的时候，可以直接**替换成内存地址。**

- 动态链接

  另外一部分将在每一次运行期间都转化为直接引用，这部分就称为**动态连接**

### 5>初始化

Java虚拟机才真正开始**执行类中编写的Java程序代码**，将主导权移交给应用程序初始化阶段就是执行类构造器**clinit方法**的过程。**clinit方法**并不是程序员在Java代码中直接编写的方法，它是**Javac编译器的自动生成物**

clinit方法是由**编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的**



# 三、类加载器

## 1.类加载器初始化的时机

1. JVM层面：会创建一个系统的类加载器，就是下面要说的`Bootstrap ClassLoader`
2. Java层面：会创建两个应用层面的类加载器`ExtClassLoader`和`AppClassLoader`

## 2.类加载器加载类的方式

加载类的方式：懒加载

## 3.五花八门的类加载器

- 引导类加载器：由JVM虚拟机实现，负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、charsets.jar（字符集）等等
- 扩展类加载器`ExtClassLoader`：负责加载**支撑JVM运行**的位于JRE的lib目录下的ext扩展目录中的JAR类包
- 应用程序类加载器`AppClassLoader`：负责**加载classPath路径下的类包**，主要加载的就是你自己写的类
- 自定义加载器：负责加载**用户自定义路径下的类包

## 4.各种类加载器加载文件的路径

- `bootStrapLoader`读取的是jre目录下最核心的包
- `extClassLoader`读取的是lib\ext目录下的文件
- `appClassLoader`读取的是应用程序java文件的编译输出路径

## 5.类加载器的初始化过程

通过new ClassLoader

AppClassLoader类的加载器有一个父类的类加载器属性是**ExtClassLoader**

ExtClassLoader父类的类加载器属性是`bootStrapLoader`



# 四、双亲委派机制

**父加载器加载失败就有子类加载器自己加载**

从AppClassLoader开始委托给ExtClassLoader再委托给BootStrapLoader开始进行加载，BootStrapLoader如果加载不到再委托给ExtClassLoader，ExtClassLoader加载不到再委托给AppClassLoader，这样一个自下而上再而下的这么一个过程

## 1.优点

1. **沙箱安全机制**：**不同的类由不同的类加载器进行加载，保护Java核心的类不被随意的修改**
2. **避免类的重复加载**：当父加载器已经加载了该类时，没有必要子类的classLoader再去加载一遍，**保证被加载的类的唯一性**



## 2.缺点

双亲委派这种类的加载模式也不是适用于所有的场景

## 3.打破双亲委派机制

重写loadclass

## 4.打破双亲委派机制的场景

1.一个Tomcat可能部署多个应用，不同的应用可能依赖的同一个第三方类库的不同版本（会造成很多大量的文件路径相同的类），这种情况下就不能通过双亲委派机制去加载，要保证每个应用的类库是独立的，相互隔离

2.web容器要支持jsp修改，jsp文件最终也需要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp是一件高频的事情，web容器需要支持jsp修改后无需重启





# 五、对象创建过程

## 1.类检查机制

虚拟机遇到一条**new指令**时，首先将去检查这个指令的参数是否能在`常量池`中定位到一个**类的符号引用**，并且检查这个符号引用代表的类**是否已经被加载、解析和初始化过，如果没有，那必须先执行相应的类加载过程**

## 2.分配内存

为对象分配空间的任务等同于**把一块确定大小的内存从Java堆中划分出来**

### 1>对象内存分配`的方式

- **指针碰撞-假设Java堆中内存是绝对规整**

- **空闲列表-假设Java堆中内存并不是规整**

- #### 如何选择内存分配方式

  选择哪种分配方式由**Java堆是否规整**决定，而Java堆是否规整又由所采用的**垃圾收集器的收集算法是否带有空间整理的能力决定**。因此当使用`Serial、ParNew`等带**整理过程的收集器**时，采用的分配算法是指针碰撞，简单又高效，而当使用CMS这种基于**清除算法的收集器**时，理论上就只能采用较为复杂的空闲列表来分配内存

### 2>分配内存时带来的`并发问题`

不同的对象在不同的线程中需要申请使用同一块内存空间

- #### CAS

- #### 本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）

  每个线程在Java堆中预先分配一小块内存**每个线程独有的一块内存空间，默认是eden区的%1，但如果预先分配的内存中放不下了，还是放到eden区，走CAS的逻辑**

### 3>对象`存储的地方`是在哪

#### a.栈内分配

1. 首先这个对象**不能占用很多的空间**，总共栈帧就那么点大，超出了肯定不行

2. 这个对象要满足**对象逃逸分析**的要求

   逃逸分析

   JVM通过**逃逸分析确定该对象不会被外部访问**，**如果不会逃逸**可以将对象在**栈上分配内存**

   JVM可以通过开启逃逸分析参数 **-XX:+DoEscapeAnalysis** 来优化对象内存位置分配，使其通过**标量替换**优先在栈上进行分配

   标量替换

   首先通过逃逸分析确定对象不会被外部访问，并且**对象可以进一步分解**时，**JVM不会创建该对象**，而是将该对象成员变量分解成**若干个被这个方法使用的成员变量所代替**，这些代替的成员变量**在栈帧或寄存器上分配空间**，这样**就不会因为没有一大块连续的内存空间导致对象内存不够分配**

   **标量替换是要在开启逃逸分析之后，才有效果，如果没有开启逃逸分析，那么也不会开启标量替换**

   开启标量替换参数：`-XX:+EliminateAllocations`

#### b.大对象

如果是大对象，那么**直接进入老年代**，如果不是大对象，那么就进行**本地线程分配缓冲（TLAB

为了避免为**大对象分配内存时的复制操作而降低效率**，因为年轻代的GC用的**标记复制**算法，如果大对象存放在年轻代，会极大的耗费**复制时间**，而Minor GC又是比较频繁发生的GC，**要保证吞吐量**，所以大对象比较适合直接进入老年代

#### c.对象从年轻代进入老年代

- 分代年龄判断

对象在survivor区每熬过一次Minor GC，分代年龄都+1，当它的年龄达到一定程度默认是15，CMS收集器为6岁，不同的垃圾回收器会稍微有点不同，这个对象就会进入到老年代中

- 动态年龄判断

**当前放对象的survivor区域里**，一批对象的总大小大于**这块survivor区域内存大小的50%（可以配置）**，那么此时**大于等于**这批对象**分代年龄最大值的对象**，就可以直接进入老年代

对象动态年龄判断机制的目的:

希望那些可能是长期存活的对象，尽早的进入老年代。

注意：**对象动态年龄判断机制一般是在Minor GC之后触发的**

- 老年代空间分配担保机制

  年轻代**每次Minor GC之前**，JVM都会计算下**老年代剩余可用空间**，如果可用空间小于年轻代里现有的所有对象大小之和，就会看一个 `-XX:-HandlePromotionFailure JDK 1.8默认设置了`的参数是否设置，这个参数就是一个担保参数，担保一下如果小于历史平均值，就不会发生Full GC

  目的：每一次MinorGC之前，判断如果大概率要发生Full GC，那么就直接执行**Full GC**，就不进行MinorGC**避免流程图中第一个MinorGC**，虽然Full GC完了之后还会执行一次Minor GC，但是这次Minor GC的压力明显会小很多



## 3.初始化

虚拟机需要**将分配到的内存空间都初始化为零值，不包括对象头**， **基本类型设置成默认值，引用类型设置成null**

## 4.设置对象头

第一块区域是**Mark Word**，用于存储对象自身的运行时数据 ，**hash码（hashCode）、GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID、偏向时间戳等等**

第二块区域是**类型指针**，**即指向它的类元数据的指针**，虚拟机通过这个类型指针来确定这个对象是哪个类的实例。

第三块区域是**数组长度**，如果对象是数组类型，那么对象头中还有一个**数组长度，占用4个字节**

### 1>Mark Word

-   分代年龄

  分代年龄在对象头中只能占4位，4位换算成十进制是2的4次方减1=15，所以分代年龄最大只能是15

  对象锁的状态从**无锁->偏向锁->轻量级锁**的过程中，**分代年龄丢失了**

  栈中LockRecord

### 2>类型指针

指向类元信息

Class类对象是存放在堆的，因为类中一些静态变量、方法等类元信息都是存放在方法区的，为了让开发人员获取到方法区里面的这些类信息，JVM提供了这么一个类对象，方便获取类信息，JVM自己内部用的还是对象头里面的类型指针

### 3>数组长度

如果对象是**数组类型**，那么对象头中还有一个**数组长度，占用4个字节**

 指针压缩：我们在查看对象头的时候，发现String类型指针的大小应该是**8个字节**，结果打印出来是**4个字节**，Object类型指针是8个字节的，最后也变成了4个字节，这就涉及到了**指针压缩**，从jdk1.6 update14开始，在64位操作系统中，JVM支持指针压缩

##### 指针压缩的目的

1. 在**64位的操作系统**上，HotSpot使用32位指针（实际存储用64位），内存使用会多出1.5倍左右，使用**较大指针在主内存和缓存之间移动数据，占用较大带宽，同时GC也会承受较大压力**，为了减少64位平台下**内存的消耗**，启用指针压缩功能
2. 在jvm中可以通过对对象指针的存入堆内存时**压缩编码**，取出到cpu寄存器后解码方式进行优化，使得JVM可以只用32位地址就可以支持更多的内存配置 **（堆内存要小于等于32G）**
3. 堆内存小于4G时，不需要启用指针压缩，jvm会自动去除高32位地址，即使用**低虚拟地址空间**
4. 堆内存大于32G时，指针压缩会失效，会强制使用64位（8字节）来对java对象寻址，这就会出现第一点的问题，所以堆内存最好不要大于**32G**

## 5.执行init方法

构造函数**，即Class文件中的**init方法



# 六、jvm垃圾收集算法

## 1.分代收集理论

根据对象存活周期的不同，将内存分为几块

分代思想的特点就是将堆分为**新生代**和老年代，然后根据各个**年代**的特点选择**合适的垃圾收集算法**

在**新生代**中，每次收集都会有大量的对象(近99%)死去，所以可以选择**复制算法**，只需要付出少量对象的**复制成本**就可以完成每次收集

在**老年代**中，**对象的存活几率较高**，复制成本太高，而且没有额外的空间给它**分配担保**，所以必须使用**标记整理算法或标记清除算法**进行垃圾收集

## 2.垃圾收集算法

### 1>标记-清除算法

标记存活的对象，统一回收所有未被标记的对象

1. 效率问题：**如果标记的对象太多，那么效率不高**
2. 空间问题：**标记清除后，会产生大量不连续的碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找 到足够的连续内存而不得不提前触发另一次垃圾收集动作

### 2>标记-复制算法

HotSpot虚拟机的**Serial、ParNew等新生代收集器**均采用了半区复制分代策 略,把新生代分为**一块较大的Eden空间和两块较小的Survivor空间**，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。

- 标记-复制最大的弊端就是**浪费内存空间

### 3>标记-整理算法

标记过程仍然与**标记-清除**算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存

- 缺点

要移动存活对象，但是如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行

- 优点

无空间碎片化问题

移动则内存回收时会更复杂，不移动则内存分配时会更复杂

折中（CMS收集器）：让JVM平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。

### 4>垃圾收集算法如何找出存活对象

#### 1.引用计数法

这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，最主要的原因是**它很难解决对象之间的循环依赖问题**

#### 2.可达性分析算法

**GC Roots**对象作为起点，从这些节点开启**向下搜索引用的对象**，找到的对象都标记成**非垃圾对象**，其余未标记的对象都是垃圾对象

GCROOT对象：

- 虚拟机栈 **(栈帧中的本地变量表)** 中引用的对象**局部变量表引用的所有对象**
- 方法区中静态属性引用的对象**引用方法区该静态属性的所有对象**
- 方法区中常量引用的对象**引用方法区中常量的所有对象**
- 本地方法栈中(Native方法)引用的对象**引用Native方法的所有对象**
- 所有被同步锁(synchronized关键字)持有的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(比如NullPointExcepiton、OutOfMemoryError)等，还有系统类加载器。



## 3.引用类型

### 1>强引用(Strong Reference)

### 2>软引用(Soft Reference)

GC完之后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉

软引用可用来**实现内存敏感的高速缓存**

### 3>弱引用(Weak Reference)

被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。GC会直接回收掉

### 4>虚引用(Phantom Reference)

为一个对象设置虚引用关联的唯一目的只是**为了能在这个对象被收集器回收时收到一个系统通知**

## 4.逃脱回收的手段-finalize方法

## 5.回收方法区

- 该类**所有的实例已经被回收**，也就是Java堆中不存在该类的任何实例
- 加载该类的**ClassLoader**已经被回收
- 该类对应的**java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法**





# 七、各种垃圾收集器

- 作用于**年轻代**的有Serial、ParNew、Parallel
- 作用于**老年代**的有CMS、Serial Old、Parallel Old
- 至于G1和G1后面的垃圾收集器就是**混合回收**

## 1.Serial收集器

是一个**串行收集器**，也就是**单线程收集器

### 1>Serial的特点

- **只会使用一条垃圾收集线程去完成垃圾收集工作**
- 在进行垃圾收集工作的时候必须暂停其他所有的工作线程**stop the world**，直到它回收结束。
- 新生代/年轻代采用**标记-复制**算法，老年代采用**标记-整理**算法。

2>Serial的缺点

- **stop the world**

3>Serial的优点

- **简单而高效(与其他收集器的单线程相比)**，对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的



## 2.ParNew收集器

ParNew收集器在新生代**采用多线程并行收集**去完成垃圾收集工作，但是**老年代还是单线程**

特点：

- **新生代采用多线程并行收集去完成垃圾收集工作**
- 在进行垃圾收集工作的时候必须暂停其他所有的工作线程**stop the world**，直到它回收结束。
- 新生代/年轻代采用**标记-复制**算法，老年代采用**标记-整理**算法

## 3.Parallel Scavenge收集器

**它的关注点在于吞吐量(高效的利用CPU)**，而**CMS等垃圾收集器**的关注点更多的是用户线程的停顿时间 **(提高用户体验)

Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于**标记-整理**算法实现。直到Parallel Old收集器出现后，**吞吐量优先**收集器终于有了合适的搭配组合，在**注重吞吐量**或者**处理器资源较为稀缺的场合**，都可以优先考虑Parallel Scavenge+Parallel Old收集器这个组合，**JDK 8默认就是用的这种组合**

特点：

- 新生代/年轻代采用**标记-复制**算法，老年代采用**标记-整理**算法
- 控制最大垃圾收集停顿时间的`-XX:MaxGCPauseMillis参数`
- 直接设置吞吐量大小:`-XX:GCTimeRatio参数`
- 自适应的调节策略：`-XX:+UseAdaptiveSizePolicy参数`

## 4.CMS垃圾收集器

是一种**以获取最短回收停顿时间**为目标的收集器，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让**垃圾收集线程与用户线程(基本上)同时工作。

### 1>收集过程

- 初始标记：暂停所有的其他线程**stop the world**，并记下GC Roots直接引用的对象，速度很快。
- 并发标记：并发标记阶段就是**从GC Roots的直接关联对象开始遍历整个对象链的过程**，这个过程很长，但是`不需要停顿用户线程`，**可以与垃圾收集线程一起并发运行**。因为用户程序继续执行，可能会有导致已经标记过的对象状态发生变化。
- 重新标记：重新标记阶段就是为了**修正并发标记期间因为用户线程继续运行而导致标记产生变动**的那一部分对象的标记记录。这个阶段的停顿时间一般会**比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法(见下面详解）做重新标记。**
- 并发清理：开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为**黑色**，不做任何处理**关于黑色，见下方三色标记算法详解**
- 并发重置：**重置本次GC过程中的标记数据。

### 2>没有stopthe wold带来的问题

- 对象引用状态的改变：原本有GC Roots引用的对象，现在没有GC Roots引用了/原本是垃圾对象，后面又复活了，又不是垃圾对象了
- 新的垃圾对象不断产生（浮动垃圾）：当浮动垃圾过多，又**发生了CMS的GC**，但上一次GC还没结束，这时候就会出现**并发失败（Concurrent Mode Failure)**，这时候JVM启动后备预案:临时启用Serial Old收集器来重新进行老年代的垃圾收集，Serial Old收集器执行的时候是会**STW**的

### 3>Parallel和CMS

- cms用户线程和GC收集线程并发执行，那么势必会增加GC收集时间 **(CPU资源被用户线程分去)**,CMS是牺牲了GC收集时间来获取用户体验

- Parallel收集器由于**stop the world**机制，GC收集线程能大大占用CPU的时间片，所以Parallel收集器GC时间比CMS收集器GC的时间短,正是由于**stop the world**，反而大大提高了吞吐量，在**堆内存**比较小的场景下**一般小于4G**，反而使用这种收集器比较合适，能尽快清理出堆内存空间,这也是JDK 8 默认使用Parallel收集器的原因之一

### 4>优点

1. **并发收集**
2. **低停顿**

### 5>缺点

1. 对CPU的资源敏感，会和服务器抢资源，也就是说**GC的时间会长**
2. 无法处理**浮动垃圾，就是在并发标记和并发清理阶段产生的垃圾对象，只能等下一次GC来收集**
3. 既然它使用的是**标记-清除**算法，那么就会导致收集结束后，会产生大量的**内存随便**，不利于后续对象的存储，当然，可以使用 **-XX:+UseCMSCompactAtFullCollection**可以让JVM在执行完**标记-清除**后，再做整理。
4. 执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，**特别是在耗时相对比较长的并发标记和并发清理阶段**，一边回收，一边程序继续执行，也许没执行完又发生了Full GC，也就是**concurrent model failure**，此时会进入**stop the world**，用**Serial old垃圾收集器来回收**

### 6>CMS的核心参数设置

1. 启用CMS：`-XX:+UseConcMarkSweepGC`
2. 设置并发的GC线程数：`-XX:ConcGCThreads`
3. FullGC之后做压缩整理，**用来减少内存碎片**：`-XX:+UseCMSCompactAtFullCollection`
4. 设置多少次Full GC之后压缩整理一次，**默认是0，说明每次FullGC之后都会压缩**：`-XX:CMSFullGCsBeforeCompaction`
5. 当老年代使用达到该比例时会触发Full GC**默认是92，注意：这是百分比，这里留8%的空间也正是为了避免上面说的concurrent model failure，如果你的系统大对象比较多，建议把这个参数调小一点**：`-XX:CMSInitiatingOccupancyFraction`
6. 只使用设定的阈值 **-XX:CMSInitiatingOccupancyFraction设置**，如果不指定，那么JVM仅在第一次使用设定值，后续会自动调整，**比如，触发了concurrent model failure，JVM就会把上述的比例值调小，如果不触发concurrent model failure，那么JVM会把这个值调大**：`-XX:+UseCMSInitiatingOccupancyOnly`
7. **在GC前启动一次Minor GC，减少老年代对年轻代的引用，降低标记阶段时的开销**，，一般CMS的GC耗时80%都在并发标记阶段**在并发标记阶段，很有可能老年代的对象会依赖年轻代的对象，也就是所说的跨代引用，如果并发标记的时候还要去跨代的寻找引用，而且这个放在新生代的对象很有可能是垃圾对象了，那么其实没必要再去标记它，所以在GC之前启动一次Minor GC**：`-XX:+CMSScavengeBeforeRemark`
8. 表示**在初始标记的时候多线程执行，缩短STW**：`-XX:+CMSParallelInitialMarkEnabled`
9. 在**重新标记的时候多线程执行，缩短STW**：`-XX:+CMSParallelRemarkEnabled`

## 5.三色标记

- **多标:** 在并发标记阶段，把一个GC Roots引用链上的对象已经标记了，但是用户线程没有停止，当方法结束的时候，这个对象链上可能都是垃圾对象**被称为浮动垃圾**，这个就是**多标**

**多标**的情况还好，就是多了些**浮动垃圾**，最多就等到下次GC的时候，这些垃圾对象还是会被回收的。**另外：针对并发标记开始后产生的新对象，通常做法是全部标记成黑色，本轮不会清除。这部分对象期间也可能变成垃圾对象，这也算浮动垃圾的一部分**

- **漏标** 在并发标记阶段，原先已经**被扫描过的对象重新有了新的引用**，导致无法被扫描

### 1>三色

**黑色:** 表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。**黑色**的对象代表已经扫描，它是安全存活的，如果有其他对象引用指向了这个对象，那么无需重新扫描一遍。**黑色对象不可能直接（不经过灰色对象）指向某个白色对象**

**灰色:** 表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过

**白色:** 表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是**白色**的，如果**在分析结束的阶段，仍然是白色的对象**，即代表**不可达**。

### 2>漏标的两个条件

- 插入一条或多条**从黑色对象到白色对象的新引用*
- 删除全部**从灰色对象到该白色对象的直接或间接引用

### 3.漏标解决方案

1. 增量更新**Incremental Update

   当黑色对象插入新的指向**白色对象**的引用关系的时候，就将这个新插入的引用记录下来，等**并发标记**结束之后，等到**重新标记阶段，会stop the world**再将这些记录过的引用关系中的**黑色对象**为根，重新扫描一次

2. 原始快照**Snapshot At The Begining, STAB**

   当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的**引用关系**记录下来，在**并发标记**结束之后，等到**重新标记阶段，会stop the world**再讲这些记录过的引用关系中的**灰色对象**为根，重新扫描一次，这样就能扫描到**白色对象**，将这些白色对象标记成**黑色对象**，**目的就是让这种对象在本次GC中存货下来

- CMS: `写屏障+增量更新`
- G1，Shenandoah：`写屏障+SATB`



## 6.G1

G1 **（Garbage First）** 是一款面向服务器的垃圾收集器，**主要针对配置多核处理器以及大容量内存的机器**，以极高概率满足**GC停顿时间要求的同时，还具备高吞吐量性能特征**，JDK 9开始默认使用**G1 垃圾收集器**

### 1>G1的内存划分

G1将一整块堆划分成多个大小相等的独立区域**Region**，JVM最多可以有**2048**个Region**默认也是2048个**。

这些独立的Region既有**Eden区、又有Survivor区、又有Old区、又有Humongous区(巨型对象区)**，也就是说G1保留了**年轻代和老年代的概念**，但不再是物理隔阂了，它们都是**可以不连续**的Region的集合。

一般**Region**大小等于**堆**大小除以2048，比如**堆**大小是4096M，则**Region**的大小是**2M**，当然可以通过JVM命令 **-XX:G1HeapRegionSize** 调整Region大小，但是推荐默认的大小调整

### a.年轻代和老年代的内存划分

**年轻代**对堆内存的占比是**5%**，如果堆大小是4096M，那么年轻代占据约200MB左右的内存，对应的**Region区域个数就是100个**

可以通过 **-XX:G1NewSizePercent**设置年轻代初始占比，在系统的运行过程中，JVM会不断的给年轻代增加更多的**Region**，但是不能超过**60%**，可以通过 **-XX:G1MaxNewSizePercent**进行调整。

年轻代中的Eden区和Survivor区对应的region也跟之前一样，默认**8：1：1**，假设年轻代现在有100个Region，那么**Eden区就是80个，survivor0就是10个，survivor1就是10个**

b.如果一个对象超过了**Region区的50%大小**，那么就被判定成**大对象**，比如上面说的，如果Region区是2M的大小，如果一个对象超过了1M，那么就放入Region区，而且一个大对象如果太大，那么会横跨多个Region来存放,full gc也会回收



### 2>G1垃圾收集的过程

- 初始标记:** 暂停其他的所有线程**STW**，并记录下**GC Roots直接引用的对象**，这步和CMS一样，**速度很快**
- 并发标记:** 同CMS的并发标记
- 最终标记:** 同CMS的重新标记，也会**STW**
- 筛选回收:** 筛选回收阶段首先对各个Region的**回收价值和成本进行排序，根据用户所期望的GC停顿STW时间来制定回收计划**，可以用 **-XX:MaxGCPauseMillis**来指定时间

G1采用复制算法回收几乎不会有太多内存碎片

CMS回收阶段是跟用户线程一起并发执行的，但是G1因为内部实现太过复杂，所以暂时没有实现并发回收

第一阶段initial mark是共用了Young GC的暂停，这是因为他们可以复用root scan操作，所以可以说global concurrent marking是伴随Young GC而发生的。第四阶段Cleanup只是回收了没有存活对象的Region，所以它并不需要STW。

Young GC发生的时机大家都知道，那什么时候发生Mixed GC呢？其实是由一些参数控制着的，另外也控制着哪些老年代Region会被选入CSet

- G1HeapWastePercent：在global concurrent marking结束之后，我们可以知道old gen regions中有多少空间要被回收，在每次YGC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生Mixed GC。 

* G1MixedGCLiveThresholdPercent：old generation region中的存活对象的占比，只有在此参数之下，才会被选入CSet。 
* G1MixedGCCountTarget：一次global concurrent marking之后，最多执行Mixed GC的次数。 
* G1OldCSetRegionThresholdPercent：一次Mixed GC中能被选入CSet的最多old generation region数量。

其他參數

| XX:G1HeapRegionSize=n              | 设置Region大小，并非最终值                                   |
| ---------------------------------- | ------------------------------------------------------------ |
| -XX:MaxGCPauseMillis               | 设置G1收集过程目标时间，默认值200ms，不是硬性条件            |
| -XX:G1NewSizePercent               | 新生代最小值，默认值5%                                       |
| -XX:G1MaxNewSizePercent            | 新生代最大值，默认值60%                                      |
| -XX:ParallelGCThreads              | STW期间，并行GC线程数                                        |
| -XX:ConcGCThreads=n                | 并发标记阶段，并行执行的线程数                               |
| -XX:InitiatingHeapOccupancyPercent | 设置触发标记周期的 Java 堆占用率阈值。默认值是45%。这里的java堆占比指的是non_young_capacity_bytes，包括old+humongous |

### 3>G1特点

- **并行与并发:** G1能充分利用CPU，多核环境下的硬件优势，使用多个CPU来缩短**STW时间**，部分其他收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让Java线程**继续执行**

- 分代收集:** 虽然G1可以不需要其他收集器配合就能独立管理整个堆，但还是保留了分代的概念

- 空间整合:** 和CMS的**标记-清除**算法不同，G1从整体上看是**标记-整理**算法，但是从局部上来看是基于**标记-复制**的算法来实现的

- 可预测的停顿:** 这是G1相对于CMS的另一个大优势，降低停顿时间是G1和CMS的共同关注点，但是G1在追求低停顿外，还能建立**可预测的停顿时间模型**，能让使用者明确指定在一个**长度为毫秒的时间片段 通过-XX:MaxGCPauseMillisk来指

  

G1默认停顿时间200ms， 如果设置太短停顿时间太短，导致每次选出来的回收集只占堆内存很小的一部分，收集器收集的速度还赶不上分配器分配的速度，导致垃圾慢慢变多，很有可能一开始收集器还能从空闲的Region区获得一些喘息的时间，但应用运行时间异常就不行了，最终占满堆引发Full GC反而降低性能，所以通常把期望值设置成100ms-300ms是比较合理的区间



### 4>g1 gc方式

G1提供了两种GC模式，Young GC和Mixed GC，两种都是完全Stop The World的。 * Young GC：选定所有年轻代里的Region。通过控制年轻代的region个数，即年轻代内存大小，来控制young GC的时间开销。 * Mixed GC：选定所有年轻代里的Region，外加根据global concurrent marking统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region。

由上面的描述可知，Mixed GC不是full GC，它只能回收部分老年代的Region，如果mixed GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行Mixed GC，就会使用serial old GC（full GC）来收集整个GC heap。所以我们可以知道，G1是不提供full GC的。

### YoungGC

YoungGC 并不是说现有的Eden区放满了就会马上触发，G1会计算下**现在Eden区回收预计需要多少**，如果回收时间远远小于**预期停顿时间 -XX:MaxGCPauseMillis指定**，那么不会立刻触发Young GC，而是会**增加年轻代的Region，继续给新对象存放**，一直到下一次Eden区放满，G1计算回收Eden区花费的时间和指定的时间相近，那么会执行YoungGC

### MixedGC

不是Full GC，老年代的堆占有率超过**可用参数-XX:InitiatingHeapOccupancyPercent**设定的值触发**MixedGC**，回收所有的Young和部分Old**根据期望的暂停时间确定old区的优先级顺序**，以及**大对象区**，正常情况下，G1的垃圾收集是先做MixedGC，主要使用**复制算法**，需要把各个Region中存活的对象，拷贝到别的Region里去，拷贝过程中如果发现**没有足够的空region去承载拷贝对象，那么就会发生一次Full GC**

### Full GC

停止系统程序，然后采用**单线程进行标记、清理和压缩整理，有点类似于Serial Old**，空闲出来的一批Region来供下一次Mixed GC来使用。

### 5>G1的参数设置

### 6>G1的调优建议

所以对G1调优来说，就是尽量避免产生Full GC，对停顿的时间做合理的设置**

所以核心还是在调节 **-XX:MaxGCPauseMills**这个参数上，在保证它的年轻代的GC不要太频繁的同时，还得考虑每次GC过后存活的对象有多少，避免存活对象过多，过早进入老年代，频繁触发MixedGC

7>**G1的使用场景**

1. 50%以上的堆被存活对象占用
2. 对象分配和晋升的速度变化非常大
3. 垃圾回收时间特别长，超过1s
4. 8GB以上的堆内存 **(建议值)**
5. 停顿时间是500ms以内

8>漏标

和CMS相同，由于在**并发标记阶段**，没有执行**STW**，所以也同样会产生漏标的场景，但是G1对于漏标的场景和CMS不同，G1是采用**SATB**的方式解决漏标场景，SATB相对**增量更新**效率会高，因为不需要在重新标记阶段再次深度扫描被删除的引用对象，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的Region，CMS就一块老年代区域，重新深度扫描的成本G1会比CMS大很多很多**跨代引用的存在，不同的Region之间都算跨代**，所以G1选择SATB而不做深度扫描，只是简单标记，等到下一轮GC再深度扫描

当然**SATB可能产生更多的浮动垃圾**，但是G1就是为了**提高用户体验**而允许浮动垃圾的**存在**

### 9>Rset     https://tech.meituan.com/2016/09/23/g1.html

全称是Remembered Set，是辅助GC过程的一种结构，典型的空间换时间工具，和Card Table有些类似。还有一种数据结构也是辅助GC的：Collection Set（CSet），它记录了GC要收集的Region集合，集合里的Region可以是任意年代的。在GC的时候，对于old->young和old->old的跨代对象引用，只要扫描对应的CSet中的RSet即可。 逻辑上说每个Region都有一个RSet，RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。而Card Table则是一种points-out（我引用了谁的对象）的结构，每个Card 覆盖一定范围的Heap（一般为512Bytes）。G1的RSet是在Card Table的基础上实现的：每个Region会记录下别的Region有指向自己的指针，并标记这些指针分别在哪些Card的范围内。 这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。

RSet究竟是怎么辅助GC的呢？在做YGC的时候，只需要选定young generation region的RSet作为根集，这些RSet记录了old->young的跨代引用，避免了扫描整个old generation。 而mixed gc的时候，old generation中记录了old->old的RSet，young->old的引用由扫描全部young generation region得到，这样也不用扫描全部old generation region。所以RSet的引入大大减少了GC的工作量。





jps：找到进程id

【jstat】虚拟机统计信息监视工具

如`jstat -gcutil 20954 1000`

- gcutil指：已使用空间站总空间的百分比。
- 20954指：pid
- 1000指：每1000毫秒查询一次，一直查。

jmap:内存快照

dump

mat:分析dump文件

通过jinfo命令来查看和调整Java进程的「运行参数」。

通过jstack命令来查看JVM「线程信息」。这个命令用常用语排查死锁相关的问题



调优：https://juejin.cn/post/6949806402743304206

GC 优化的核心思路在于，尽可能让对象在新生代中分配和回收，尽量避免过多对象进入老年代，导致对老年代频繁进行垃圾回收，同时给系统足够的内存减少新生代垃圾回收次数，进行系统分析和优化也是围绕着这个思路展开。



